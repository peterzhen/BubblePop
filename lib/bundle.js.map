{"version":3,"sources":["webpack:///webpack/bootstrap 12d56fb72f11989bdde7","webpack:///./lib/bubblepop.js","webpack:///./lib/game.js","webpack:///./lib/bubble.js","webpack:///./lib/player.js","webpack:///./lib/shooter.js","webpack:///./lib/util.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;AChBA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA8B,aAAa;AAC3C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,UAAU;AAC7B;AACA,wBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,oBAAmB,mBAAmB;AACtC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;ACnFA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;;;;;;AC/FA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;;;;;ACtDA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA","file":"./lib/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 12d56fb72f11989bdde7\n **/","const Game = require(\"./game\");\n\nconst init =  () => {\n  const canvasEl = document.getElementById(\"canvas\");\n  canvasEl.width = 275;\n  canvasEl.height = 455;\n  const ctx = canvasEl.getContext(\"2d\");\n\n  window.stage = new createjs.Stage(\"canvas\");\n  const game = new Game(window.stage);\n  game.fillCanvas();\n\n  createjs.Ticker.setFPS(60);\n  createjs.Ticker.addEventListener(\"tick\", game.tick);\n}\n\n$(document).ready(init);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/bubblepop.js\n ** module id = 0\n ** module chunks = 0\n **/","const Bubble = require(\"./bubble\");\nconst Player = require(\"./player\");\n\nclass Game {\n  constructor(stage){\n    this.stage = stage;\n    this.bubbleGrid = [];\n    this.rowOffset = 0;\n    this.player = new Player({ game: this });\n    this.currentBubble = this.player.currentBubble;\n    this.nextBubble = this.player.nextBubble;\n    this.shooter = this.player.shooter;\n    this.generateBubbles(rows, cols);\n\n    this.tick = this.tick.bind(this);\n  }\n\n  tick(){\n    if (this.player.shooting){\n      this.currentBubble.tick();\n      this.player.tick();\n      this.checkCollisions();\n    }\n    stage.update();\n  }\n\n  generateBubbles(rows, cols) {\n    for (let i = 0; i < cols; i++) {\n        this.bubbleGrid[i] = [];\n        for (let j = 0; j < rows; j++) {\n          if (i % 2 === 1){\n            if (j < rows - 1){\n              this.bubbleGrid[i][j] = -1;\n            }\n          } else {\n            this.bubbleGrid[i][j] = -1;\n          }\n        }\n    }\n\n    level1.forEach( (bubble) => {\n      if (bubble.i % 2 === 1){\n        if (bubble.j < rows - 1){\n          this.bubbleGrid[bubble.i][bubble.j] = new Bubble({\n            x: bubble.j * rowWidth,\n            y: bubble.i * rowHeight,\n            shifted: true,\n            sheet: bubble.sheet,\n            color: bubble.color,\n            processed: false\n          });\n        }\n      } else {\n        this.bubbleGrid[bubble.i][bubble.j] = new Bubble({\n          x: bubble.j * rowWidth,\n          y: bubble.i * rowHeight,\n          shifted: false,\n          sheet: bubble.sheet,\n          color: bubble.color,\n          processed: false\n        });\n      }\n    });\n  }\n\n  checkCollisions(){\n\n    this.allBubbles().forEach((bubble) => {\n      if (bubble !== -1) {\n        if (this.checkCollision(bubble.bubble, this.currentBubble.bubble)){\n          this.currentBubble.stopBubble();\n          this.currentBubble.snapBubble();\n          this.addToGrid(this.currentBubble);\n          this.burstMatching(this.currentBubble);\n\n        }\n      }\n    });\n  }\n\n  addToGrid(bubble){\n    const grid = bubble.getGridPosition();\n    this.bubbleGrid[grid.y][grid.x] = bubble;\n  }\n\n  checkCollision(bubble1, bubble2){\n    const dx = bubble1.x - bubble2.x;\n    const dy = bubble1.y - bubble2.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    if (distance < bubbleWidth) return true;\n\n    return false;\n  }\n\n  burstMatching(bubble){\n    const matchingBubbles = this.findMatching(bubble);\n\n    if (matchingBubbles.length >= 3){\n      matchingBubbles.forEach( bubble => {\n        let bubbleGrid = bubble.getGridPosition();\n        this.bubbleGrid[bubbleGrid.y][bubbleGrid.x] = -1;\n        this.stage.removeChild(bubble.bubble)\n      });\n    }\n  }\n\n  findMatching(bubble){\n    this.resetBubbles();\n\n    const uncheckedBubbles = [bubble];\n    bubble.processed = true;\n    const matching = [];\n\n    while (uncheckedBubbles.length > 0){\n      let currentBubble = uncheckedBubbles.pop();\n\n      if (currentBubble.color === bubble.color) {\n         matching.push(currentBubble);\n\n         let neighbors = this.getNeighbors(currentBubble);\n\n         neighbors.forEach( bubble => {\n           if(!bubble.processed){\n             uncheckedBubbles.push(bubble);\n             bubble.processed = true;\n           }\n         });\n      }\n    }\n\n    return matching;\n  }\n\n  getNeighbors(bubble) {\n    let grid = bubble.getGridPosition();\n    const neighbors = [];\n\n    const deltas = neighborDeltas[grid.y % 2];\n\n    for (let i = 0; i < deltas.length; i++) {\n        let deltax = grid.x + deltas[i][0];\n        let deltay = grid.y + deltas[i][1];\n\n        if (deltax >= 0 && deltax < rows && deltay >= 0 && deltay < cols) {\n            if (this.bubbleGrid[deltay][deltax] !== -1) neighbors.push(this.bubbleGrid[deltay][deltax]);\n        }\n    }\n\n    return neighbors;\n  }\n\n  dropFloatingBubbles(){\n\n    \n  }\n\n  resetBubbles() {\n    let flatBubbles = [].concat.apply([], this.bubbleGrid);\n    flatBubbles.forEach( bubble => {\n      if ( bubble !== -1 ) bubble.processed = false;\n    });\n  }\n\n  allBubbles(){\n    let flatBubbles = [].concat.apply([], this.bubbleGrid);\n    const bubbles = flatBubbles.filter ( bubble => bubble !== -1 );\n    return bubbles;\n  }\n\n  allObjects() {\n    return [].concat(this.allBubbles(), this.currentBubble, this.nextBubble);\n  }\n\n  fillCanvas(){\n    this.stage.addChild(this.shooter.shooter);\n    this.allObjects().map ( (bubble) => this.stage.addChild(bubble.bubble));\n  }\n\n  updateBubbles(currentBubble, nextBubble){\n    this.currentBubble = currentBubble;\n    this.nextBubble = nextBubble;\n  }\n}\n\nmodule.exports = Game;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/game.js\n ** module id = 1\n ** module chunks = 0\n **/","class Bubble {\n  constructor(options){\n    this.x = options.x;\n    this.y = options.y;\n    this.vx = 0;\n    this.vy = 0;\n    this.shifted = options.shifted;\n    this.color = options.color;\n    this.processed = false;\n    this.bubble = new createjs.Sprite(options.sheet, \"animate\");\n    this.pseudoBubble = new createjs.Shape();\n    this.createBubble(this.color);\n  }\n\n  tick(){\n    this.x += this.vx;\n    this.y += this.vy;\n\n    //bounce sides\n    if (this.x <= 0 || this.x + 34 >= window.stage.canvas.width ) {\n      this.vx = -this.vx;\n    }\n\n    //stick top\n    if ( this.y <= 0 ){\n      this.y = 0;\n      this.stopBubble();\n      this.snapBubble();\n    }\n\n    this.updateBubble(this.x, this.y);\n  }\n  // window.blueBubble = new createjs.Sprite(blueBubble, \"animate\");\n\n  createBubble(color){\n    // this.bubble.graphics.beginFill(\"red\").drawCircle(0, 0, 15);\n    this.bubble.x = this.x;\n    if (this.shifted) this.shiftRow();\n    this.bubble.y = this.y;\n  }\n\n  updateBubble(xpos, ypos, shifted = this.shifted){\n    this.x = xpos;\n    this.y = ypos;\n    this.shifted = shifted;\n    this.bubble.x = this.x;\n    if (this.shifted) this.shiftRow();\n    this.bubble.y = this.y;\n  }\n\n  getGridPosition(rowOffset = 0){\n    const gridy = Math.floor((this.y + radius) / rowHeight);\n\n    let offset = 0;\n    //add rowoffset? (gridy + rowoffset) ass row grows\n    if ((gridy  + rowOffset) % 2 === 1) offset = radius;\n\n    const gridx = Math.floor(((this.x - offset) + radius) / rowWidth);\n\n    return {\n      x: gridx,\n      y: gridy\n    }\n  }\n\n  snapBubble(rowOffset){\n    const grid = this.getGridPosition(rowOffset = 0);\n    const x = grid.x * 34;\n    const y = grid.y * 30;\n    //TODO: snap to closest grid position and check if bubble exists in current grid\n    grid.y % 2 === 1 ? this.updateBubble(x, y, true) : this.updateBubble(x, y);\n  }\n\n  stopBubble(){\n    this.vx = 0;\n    this.vy = 0;\n  }\n\n  shiftRow(){\n    this.bubble.x += radius;\n  }\n}\n\nmodule.exports = Bubble;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/bubble.js\n ** module id = 2\n ** module chunks = 0\n **/","const Bubble = require(\"./bubble\");\nconst Shooter = require(\"./shooter\");\n\nconst currentBubbleX = 135;\nconst currentBubbleY = 390;\nconst nextBubbleX = 90;\nconst nextBubbleY = 410;\n\nclass Player {\n  constructor(options){\n    this.currentBubble;\n    this.nextBubble;\n    this.shooting = false;\n    this.game = options.game;\n    this.initStage();\n    this.shooter = new Shooter();\n    this.bindKeyHandlers();\n\n    this.updateGameBubble = this.updateGameBubble.bind(this);\n  }\n\n  tick(){\n    if (this.shooting && this.currentBubble.vx === 0 && this.currentBubble.vy === 0){\n      this.shooting = false;\n      this.setCurrentBubble();\n      this.setNextBubble();\n      this.updateGameBubble();\n    }\n  }\n\n  bindKeyHandlers(){\n    document.addEventListener(\"keydown\", (event) => {\n      switch(event.keyCode){\n\n        case 32:\n        event.preventDefault();\n        this.shootBubble();\n\n        default:\n          return;\n      }\n    });\n  }\n\n  initStage() {\n    const currentRandom = randomColor();\n    this.currentBubble = new Bubble({\n      x: currentBubbleX,\n      y: currentBubbleY,\n      shifted: false,\n      sheet: currentRandom.sheet,\n      color: currentRandom.color\n    });\n\n    const nextRandom = randomColor();\n    this.nextBubble = new Bubble({\n      x: nextBubbleX,\n      y: nextBubbleY,\n      shifted: false,\n      sheet: nextRandom.sheet,\n      color: nextRandom.color\n    });\n  }\n\n  shootBubble(){\n    if (this.shooting === false){\n      this.shooter.fireBubble(this.currentBubble);\n      this.shooting = true;\n\n    }\n  }\n\n  updateGameBubble(){\n    this.game.updateBubbles(this.currentBubble, this.nextBubble)\n  }\n\n  setCurrentBubble(){\n    this.currentBubble = this.nextBubble;\n    this.currentBubble.updateBubble(currentBubbleX, currentBubbleY);\n    this.shooter.updateCurrentBubble(this.currentBubble);\n  }\n\n  setNextBubble(){\n    const newBubble = randomColor();\n    this.nextBubble = new Bubble({\n      x: nextBubbleX,\n      y: nextBubbleY,\n      shifted: false,\n      sheet: newBubble.sheet,\n      color: newBubble.color\n    });\n    window.stage.addChild(this.nextBubble.bubble);\n  }\n}\n\nmodule.exports = Player;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/player.js\n ** module id = 3\n ** module chunks = 0\n **/","const Player = require('./player');\nconst Util = require('./util');\n\nclass Shooter {\n  constructor (){\n    this.shooter = this.createShooter();\n    this.handleRotation = this.handleRotation.bind(this);\n\n    this.bindKeyHandlers();\n  }\n\n  bindKeyHandlers(){\n    document.addEventListener(\"keydown\", this.handleRotation);\n  }\n\n  handleRotation(event) {\n    const code = event.keyCode;\n    if (code === 37){\n      event.preventDefault();\n      if (this.shooter.rotation > -85) this.shooter.rotation -= 2.5;\n    } else if (code === 39){\n      event.preventDefault();\n      if (this.shooter.rotation < 85) this.shooter.rotation += 2.5;\n    }\n  }\n\n  fireBubble(bubble){\n    const rad = Util.convertToRads(this.shooter.rotation + 90);\n    bubble.vx = Math.cos(rad)* -13;\n    bubble.vy = Math.sin(rad)* -13;\n  }\n\n  createShooter(){\n    const img = new Image();\n    img.src = \"./assets/images/shooter.png\";\n    const shooter = new createjs.Bitmap(img);\n\n    const shooterContainer = new createjs.Container();\n    shooterContainer.x = 150;\n    shooterContainer.y = 410;\n    shooter.regX = 11.5;\n    shooter.regY = 40.5;\n    shooter.x = 0;\n    shooter.y = 0;\n    shooterContainer.addChild(shooter);\n    return shooterContainer;\n  }\n\n  updateCurrentBubble(bubble){\n    this.currentBubble = bubble;\n  }\n\n}\n\nmodule.exports = Shooter;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/shooter.js\n ** module id = 4\n ** module chunks = 0\n **/","const Util = {\n\n  convertToDeg (rad) {\n    return rad * 180 / Math.PI;\n  },\n\n  convertToRads (deg) {\n    return deg * Math.PI / 180;\n  },\n\n  circleIntersection(x1, y1, r1, x2, y2, r2) {\n      // Calculate the distance between the centers\n      var dx = x1 - x2;\n      var dy = y1 - y2;\n      var len = Math.sqrt(dx * dx + dy * dy);\n\n      if (len < r1 + r2) {\n          // Circles intersect\n          return true;\n      }\n\n      return false;\n  }\n\n\n};\n\nmodule.exports = Util;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/util.js\n ** module id = 5\n ** module chunks = 0\n **/"],"sourceRoot":""}
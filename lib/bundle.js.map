{"version":3,"sources":["webpack:///webpack/bootstrap 5d4f75b5aad787bedb77","webpack:///./lib/bubblepop.js","webpack:///./lib/game.js","webpack:///./lib/bubble.js","webpack:///./lib/player.js","webpack:///./lib/shooter.js","webpack:///./lib/util.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;AChBA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,aAAa;AAC3C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,UAAU;AAC7B;AACA,wBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,QAAO;AACP;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,oBAAmB,mBAAmB;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;ACvXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;AC5FA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;;;;;;AChGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;;;;;ACvDA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA","file":"./lib/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 5d4f75b5aad787bedb77\n **/","const Game = require(\"./game\");\n\nconst init =  () => {\n  const canvasEl = document.getElementById(\"canvas\");\n  canvasEl.width = 275;\n  canvasEl.height = 455;\n  const ctx = canvasEl.getContext(\"2d\");\n\n  window.stage = new createjs.Stage(\"canvas\");\n  const game = new Game(window.stage);\n  game.fillCanvas();\n\n  createjs.Ticker.setFPS(60);\n  createjs.Ticker.addEventListener(\"tick\", game.tick);\n}\n\n$(document).ready(init);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/bubblepop.js\n ** module id = 0\n ** module chunks = 0\n **/","const Bubble = require(\"./bubble\");\nconst Player = require(\"./player\");\n\nclass Game {\n  constructor(stage){\n    this.stage = stage;\n    this.bubbleGrid = [];\n    window.rowOffset = 0;\n    this.currentLevel = 0;\n    this.turnCount = 0;\n    this.score = 0;\n    this.bricks = [];\n    this.player = new Player({ game: this });\n    this.currentBubble = this.player.currentBubble;\n    this.nextBubble = this.player.nextBubble;\n    this.shooter = this.player.shooter;\n    this.generateBubbles(rows, cols);\n    // this.startModal();\n\n    this.tick = this.tick.bind(this);\n  }\n\n  resetBoard(){\n    const gameContainer = document.getElementsByClassName(\"game-container\");\n    gameContainer[0].style.backgroundColor = 'rgb(94, 168, 214)';\n    this.stage.removeAllChildren();\n    this.bubbleGrid = [];\n    this.turnCount = 0;\n    window.rowOffset = 0;\n    this.player = new Player({ game: this });\n    this.currentBubble = this.player.currentBubble;\n    this.nextBubble = this.player.nextBubble;\n    this.shooter = this.player.shooter;\n    this.generateBubbles(rows, cols);\n\n    this.fillCanvas();\n  }\n\n  resetGame(){\n    this.currentLevel = 0;\n    this.resetBoard();\n  }\n\n  nextLevel(){\n    this.currentLevel += 1;\n    this.resetBoard();\n  }\n\n  tick(){\n    this.checkGameOver();\n    this.allBubbles().forEach(bubble => bubble.tick());\n    if (this.player.shooting){\n      this.currentBubble.tick();\n      this.player.tick();\n      this.checkCollisions();\n      this.checkGameOver();\n      this.checkTurnCount();\n    }\n    stage.update();\n  }\n\n  generateBubbles(rows, cols) {\n    for (let i = 0; i < rows; i++) {\n        this.bubbleGrid[i] = [];\n        for (let j = 0; j < cols; j++) {\n          if (i % 2 === 1){\n            if (j < cols - 1){\n              this.bubbleGrid[i][j] = -1;\n            }\n          } else {\n            this.bubbleGrid[i][j] = -1;\n          }\n        }\n    }\n\n    levels[this.currentLevel].forEach( (bubble) => {\n      if (bubble.i % 2 === 1){\n        if (bubble.j < cols - 1){\n          this.bubbleGrid[bubble.i][bubble.j] = new Bubble({\n            x: bubble.j * rowWidth,\n            y: bubble.i * rowHeight,\n            shifted: true,\n            sheet: bubble.sheet,\n            color: bubble.color,\n            processed: false\n          });\n        }\n      } else {\n        this.bubbleGrid[bubble.i][bubble.j] = new Bubble({\n          x: bubble.j * rowWidth,\n          y: bubble.i * rowHeight,\n          shifted: false,\n          sheet: bubble.sheet,\n          color: bubble.color,\n          processed: false\n        });\n      }\n    });\n  }\n\n  checkTurnCount(){\n    const gameContainer = document.getElementsByClassName(\"game-container\");\n    if (this.turnCount < 3){\n      gameContainer[0].style.backgroundColor = 'rgb(133, 226, 127)';\n    } else if (this.turnCount === 3){\n      gameContainer[0].style.backgroundColor = 'rgb(216, 171, 112)';\n    } else if (this.turnCount === 4){\n      gameContainer[0].style.backgroundColor = 'rgb(224, 85, 85)';\n    } else if (this.turnCount === 5) {\n      gameContainer[0].style.backgroundColor = 'rgb(133, 226, 127)';\n      this.addBricks();\n      this.turnCount = 0;\n      window.rowOffset += 1;\n      this.allBubbles().forEach( bubble => {\n        bubble.y += rowHeight;\n      });\n\n      this.bubbleGrid.splice(-1,1);\n    }\n  }\n\n  checkCollisions(){\n    this.allBubbles().forEach((bubble) => {\n      if (bubble !== -1) {\n        if (this.checkCollision(bubble.bubble, this.currentBubble.bubble)){\n          this.currentBubble.stopBubble();\n          this.currentBubble.snapBubble();\n          this.addToGrid(this.currentBubble);\n          this.burstMatching(this.currentBubble);\n        }\n      }\n    });\n\n    if (this.currentBubble.y <= (window.rowOffset * rowHeight)){\n      this.currentBubble.stopBubble();\n      this.currentBubble.snapBubble();\n      this.addToGrid(this.currentBubble);\n      this.burstMatching(this.currentBubble);\n    }\n  }\n\n  addBricks(){\n    this.bricks.forEach( brick => {\n      brick.y += 30;\n    });\n    const brick = new createjs.Bitmap(\"./assets/images/bricks.png\");\n    brick.x = 0;\n    brick.y = -5;\n    this.bricks.push(brick);\n    this.stage.addChild(brick);\n  }\n\n  addToGrid(bubble){\n    const grid = bubble.getGridPosition();\n    this.bubbleGrid[grid.y][grid.x] = bubble;\n  }\n\n  checkCollision(bubble1, bubble2){\n    const dx = bubble1.x - bubble2.x;\n    const dy = bubble1.y - bubble2.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    if (distance < bubbleWidth) return true;\n\n    return false;\n  }\n\n  burstMatching(bubble){\n    const matchingBubbles = this.findMatching(bubble);\n\n    if (matchingBubbles.length >= 3){\n\n      matchingBubbles.forEach( bubble => {\n        this.removeBubble(bubble);\n      });\n      this.dropFloatingBubbles();\n    } else {\n      this.turnCount++;\n    }\n  }\n\n  findMatching(bubble){\n    this.resetBubbles();\n\n    const uncheckedBubbles = [bubble];\n    bubble.processed = true;\n    const matching = [];\n\n    while (uncheckedBubbles.length > 0){\n      let currentBubble = uncheckedBubbles.pop();\n\n      if (currentBubble.color === bubble.color) {\n         matching.push(currentBubble);\n\n         let neighbors = this.getNeighbors(currentBubble);\n\n         neighbors.forEach( bubble => {\n           if(!bubble.processed){\n             uncheckedBubbles.push(bubble);\n             bubble.processed = true;\n           }\n         });\n      }\n    }\n\n    return matching;\n  }\n\n  dropFloatingBubbles(){\n    this.resetBubbles();\n\n    let floating = [];\n\n    this.allBubbles().forEach( bubble => {\n      if(!bubble.processed){\n\n        const cluster = this.findFloating(bubble);\n\n        if (cluster.every( bubble => bubble.y !== (window.rowOffset * rowHeight))){\n          floating = floating.concat(cluster);\n        }\n      }\n    });\n\n    floating.forEach( bubble => {\n      const grid = bubble.getGridPosition();\n      bubble.vy = 13;\n      setTimeout(() => {\n        this.bubbleGrid[grid.y][grid.x] = -1;\n        stage.removeChild(bubble.bubble);\n      }, 1000);\n    });\n  }\n\n  findFloating(bubble) {\n    const unchecked = [bubble];\n    bubble.processed = true;\n    const floating = [];\n\n    while (unchecked.length > 0) {\n      const currentBubble = unchecked.pop();\n\n      floating.push(currentBubble);\n\n      const neighbors = this.getNeighbors(currentBubble);\n\n      neighbors.forEach( bubble => {\n        if(!bubble.processed){\n          unchecked.push(bubble);\n          bubble.processed = true;\n        }\n      });\n    }\n\n    return floating;\n  }\n\n  getNeighbors(bubble) {\n    let grid = bubble.getGridPosition();\n    const neighbors = [];\n\n    const deltas = grid.y % 2 === 1 ? oddDeltas : evenDeltas;\n\n    for (let i = 0; i < deltas.length; i++) {\n      let deltax = grid.x + deltas[i][1];\n      let deltay = grid.y + deltas[i][0];\n\n      if (deltax >= 0 && deltax < cols && deltay >= 0 && deltay < rows) {\n        if (this.bubbleGrid[deltay][deltax]){\n          if (this.bubbleGrid[deltay][deltax] !== -1){\n            neighbors.push(this.bubbleGrid[deltay][deltax]);\n          }\n        }\n      }\n    }\n    return neighbors;\n  }\n\n  removeBubble(bubble){\n    const grid = bubble.getGridPosition();\n    this.bubbleGrid[grid.y][grid.x] = -1;\n    stage.removeChild(bubble.bubble);\n  }\n\n  resetBubbles() {\n    let flatBubbles = [].concat.apply([], this.bubbleGrid);\n    flatBubbles.forEach( bubble => {\n      if ( bubble !== -1 ) bubble.processed = false;\n    });\n  }\n\n  allBubbles(){\n    let flatBubbles = [].concat.apply([], this.bubbleGrid);\n    const bubbles = flatBubbles.filter ( bubble => bubble !== -1 );\n    return bubbles;\n  }\n\n  allObjects() {\n    return [].concat(this.allBubbles(), this.currentBubble, this.nextBubble);\n  }\n\n  fillCanvas(){\n    this.stage.addChild(this.shooter.shooter);\n    this.allObjects().map ( (bubble) => this.stage.addChild(bubble.bubble));\n  }\n\n  updateBubbles(currentBubble, nextBubble){\n    this.currentBubble = currentBubble;\n    this.nextBubble = nextBubble;\n  }\n\n  checkGameOver(){\n    this.checkLose();\n    this.checkWin();\n  }\n\n  checkLose(){\n    const lastRow = this.bubbleGrid[this.bubbleGrid.length - 1];\n    const remainingBubbles = lastRow.filter( bubble => bubble !== -1);\n    if (remainingBubbles.length > 0){\n      this.openModal(\"YOU LOSE, TRY AGAIN!\");\n      this.resetGame();\n    }\n  }\n\n  checkWin(){\n    if (this.bubbleGrid[0].filter( bubble => bubble !== -1).length === 0){\n      if (this.currentLevel === maxLevel){\n        this.openModal(\"YOU WIN!\");\n        this.resetGame();\n      } else {\n        this.openModal(\"GOOD JOB!, PREPARE FOR THE NEXT LEVEL!\");\n        this.nextLevel();\n      }\n    }\n  }\n\n  openModal(text){\n    const modal = document.getElementById('modal');\n    const modalText = document.getElementById('modal-text');\n    modalText.innerHTML = text;\n    modal.style.display = \"block\";\n\n    setTimeout( () => {\n      modal.style.display = \"none\";\n    }, 2000);\n\n    window.onclick = event => {\n      if (event.target == modal) {\n          modal.style.display = \"none\";\n      }\n    }\n  }\n\n  startModal(){\n    const modal = document.getElementById('modal');\n    const modalText = document.getElementById('modal-text');\n    modalText.innerHTML = \"Welcome to BubblePop!  Click on the Start button to begin\";\n    modal.style.display = \"block\";\n    //TODO change modal dimensions and add start button to start modal\n    // modal.style.height = 600;\n\n    window.onclick = event => {\n      if (event.target == modal) {\n          modal.style.display = \"none\";\n          this.generateBubbles(rows, cols);\n      }\n    }\n  }\n\n  restartModal(){\n    \n  }\n}\n\nmodule.exports = Game;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/game.js\n ** module id = 1\n ** module chunks = 0\n **/","class Bubble {\n  constructor(options){\n    this.x = options.x;\n    this.y = options.y;\n    this.vx = 0;\n    this.vy = 0;\n    this.shifted = options.shifted;\n    this.color = options.color;\n    this.processed = false;\n    this.bubble = new createjs.Sprite(options.sheet, \"animate\");\n    this.pseudoBubble = new createjs.Shape();\n    this.createBubble(this.color);\n  }\n\n  tick(){\n    this.x += this.vx;\n    this.y += this.vy;\n\n    //bounce sides\n    if (this.x <= 0 || this.x + 34 >= window.stage.canvas.width ) {\n      this.vx = -this.vx;\n    }\n\n    // stick top\n    if ( this.y <= 0 ){\n      this.y = 0;\n    }\n\n    this.updateBubble(this.x, this.y);\n  }\n  // window.blueBubble = new createjs.Sprite(blueBubble, \"animate\");\n\n  createBubble(color){\n    // this.bubble.graphics.beginFill(\"red\").drawCircle(0, 0, 15);\n    this.bubble.x = this.x;\n    if (this.shifted) this.shiftRow();\n    this.bubble.y = this.y;\n  }\n\n  updateBubble(xpos, ypos, shifted = this.shifted){\n    this.x = xpos;\n    this.y = ypos;\n    this.shifted = shifted;\n    this.bubble.x = this.x;\n    if (this.shifted) this.shiftRow();\n    this.bubble.y = this.y;\n  }\n\n  getGridPosition(){\n    const yOffset = window.rowOffset * rowHeight;\n    let gridy = Math.floor(((this.y - yOffset) + radius) / rowHeight);\n\n    let offset = 0;\n    if (gridy % 2 === 1) offset = radius;\n\n    let gridx = Math.floor(((this.x - offset) + radius) / rowWidth);\n\n    if (gridy < 0) gridy = 0;\n    if (gridx < 0) gridx = 0;\n    if (gridx >= cols - 1) {\n      gridx = cols - 1;\n      if (offset > 0) gridx--;\n    }\n    return {\n      x: gridx,\n      y: gridy\n    }\n  }\n\n  snapBubble(){\n    let grid = this.getGridPosition();\n    const yOffset = window.rowOffset * rowHeight;\n    const x = grid.x * 34;\n    const y = (grid.y * 30) + yOffset;\n    //TODO: snap to closest grid position and check if bubble exists in current grid\n    if (grid.y % 2 === 1){\n      this.updateBubble(x, y, true);\n    } else {\n      this.updateBubble(x, y);\n    }\n  }\n\n  stopBubble(){\n    this.vx = 0;\n    this.vy = 0;\n  }\n\n  shiftRow(){\n    this.bubble.x += radius;\n  }\n}\n\nmodule.exports = Bubble;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/bubble.js\n ** module id = 2\n ** module chunks = 0\n **/","const Bubble = require(\"./bubble\");\nconst Shooter = require(\"./shooter\");\n\nconst currentBubbleX = 115;\nconst currentBubbleY = 390;\nconst nextBubbleX = 60;\nconst nextBubbleY = 410;\n\nclass Player {\n  constructor(options){\n    this.currentBubble;\n    this.nextBubble;\n    this.shooting = false;\n    this.game = options.game;\n    this.initStage();\n    this.shooter = new Shooter();\n    this.bindKeyHandlers();\n\n    this.updateGameBubble = this.updateGameBubble.bind(this);\n  }\n\n  tick(){\n    if (this.shooting && this.currentBubble.vx === 0 && this.currentBubble.vy === 0){\n      this.shooting = false;\n      this.setCurrentBubble();\n      this.setNextBubble();\n      this.updateGameBubble();\n    }\n  }\n\n  bindKeyHandlers(){\n    document.addEventListener(\"keydown\", (event) => {\n      const code = event.keyCode;\n\n      if (code === 32 ||\n          code === 87 ||\n          code === 38){\n        event.preventDefault();\n        this.shootBubble();\n      }\n    });\n  }\n\n  initStage() {\n    let currentRandom = randomColor(this.game.currentLevel);\n    if (this.game.currentLevel === 1){\n      currentRandom = allSprites[0];\n    }\n    this.currentBubble = new Bubble({\n      x: currentBubbleX,\n      y: currentBubbleY,\n      shifted: false,\n      sheet: currentRandom.sheet,\n      color: currentRandom.color\n    });\n\n    const nextRandom = randomColor(this.game.currentLevel);\n    this.nextBubble = new Bubble({\n      x: nextBubbleX,\n      y: nextBubbleY,\n      shifted: false,\n      sheet: nextRandom.sheet,\n      color: nextRandom.color\n    });\n  }\n\n  shootBubble(){\n    if (this.shooting === false){\n      this.shooter.fireBubble(this.currentBubble);\n      this.shooting = true;\n    }\n  }\n\n  updateGameBubble(){\n    this.game.updateBubbles(this.currentBubble, this.nextBubble)\n  }\n\n  setCurrentBubble(){\n    this.currentBubble = this.nextBubble;\n    this.currentBubble.updateBubble(currentBubbleX, currentBubbleY);\n    this.shooter.updateCurrentBubble(this.currentBubble);\n  }\n\n  setNextBubble(){\n    const newBubble = randomColor(this.game.currentLevel);\n    this.nextBubble = new Bubble({\n      x: nextBubbleX,\n      y: nextBubbleY,\n      shifted: false,\n      sheet: newBubble.sheet,\n      color: newBubble.color\n    });\n    window.stage.addChild(this.nextBubble.bubble);\n  }\n}\n\nmodule.exports = Player;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/player.js\n ** module id = 3\n ** module chunks = 0\n **/","const Player = require('./player');\nconst Util = require('./util');\n\nclass Shooter {\n  constructor (){\n    this.shooter = this.createShooter();\n    this.handleRotation = this.handleRotation.bind(this);\n\n    this.bindKeyHandlers();\n  }\n\n  bindKeyHandlers(){\n    document.addEventListener(\"keydown\", this.handleRotation);\n  }\n\n  handleRotation(event) {\n    const code = event.keyCode;\n\n    if (code === 37 || code === 65){\n      event.preventDefault();\n      if (this.shooter.rotation > -85) this.shooter.rotation -= 2.5;\n    } else if (code === 39 || code === 68){\n      event.preventDefault();\n      if (this.shooter.rotation < 85) this.shooter.rotation += 2.5;\n    }\n  }\n\n  fireBubble(bubble){\n    const rad = Util.convertToRads(this.shooter.rotation + 90);\n    bubble.vx = Math.cos(rad)* -13;\n    bubble.vy = Math.sin(rad)* -13;\n  }\n\n  createShooter(){\n    const img = new Image();\n    img.src = \"./assets/images/shooter.png\";\n    const shooter = new createjs.Bitmap(img);\n\n    const shooterContainer = new createjs.Container();\n    shooterContainer.x = 130;\n    shooterContainer.y = 410;\n    shooter.regX = 11.5;\n    shooter.regY = 40.5;\n    shooter.x = 0;\n    shooter.y = 0;\n    shooterContainer.addChild(shooter);\n    return shooterContainer;\n  }\n\n  updateCurrentBubble(bubble){\n    this.currentBubble = bubble;\n  }\n\n}\n\nmodule.exports = Shooter;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/shooter.js\n ** module id = 4\n ** module chunks = 0\n **/","const Util = {\n\n  convertToDeg (rad) {\n    return rad * 180 / Math.PI;\n  },\n\n  convertToRads (deg) {\n    return deg * Math.PI / 180;\n  },\n\n  circleIntersection(x1, y1, r1, x2, y2, r2) {\n      // Calculate the distance between the centers\n      var dx = x1 - x2;\n      var dy = y1 - y2;\n      var len = Math.sqrt(dx * dx + dy * dy);\n\n      if (len < r1 + r2) {\n          return true;\n      }\n\n      return false;\n  }\n\n};\n\nmodule.exports = Util;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/util.js\n ** module id = 5\n ** module chunks = 0\n **/"],"sourceRoot":""}